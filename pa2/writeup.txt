1. In target1.c file, I saw here is a local variable inside foo, char buf[640], so here is a way to sploit it through overflow the stack of foo. Cause the default size of buf is 640, to overflow it, I add 100 offset to make the new overflow size as 740. Refer to Aleph One's paper, I use a similar logic to do this, in gdb I got the address of buf in foo, and I put it into my new buf, and at the ending of buf, I put the shellcode which I wish could be executed after I sploit, then the target will got a overflow attack and execute my shellcode.

2. In target2.c file, I saw here is a local variable inside bar, char buf[109], so here is a way to exploit it through overflow the stack of bar. Refer to Aleph One's paper and discussion slide, I notice that I need to get the address of buf and I should rewrite the little-endian of foo's ebp. Using gdb I could get the address of buf, and then I add the address into my new buff array and then I put shellcode into it, cause I desigh the size of my new buff is greater than the origin one 2, so I know I should rewrite the last cell of my new buf which now in the liitle-endian of ebp and replace it with 0xe0 which I got as ebp of bar to redirect the place the return to.

3. In target3.c file, I notice that the count would be checked inside foo, so I can make a integer overflow for it. The size of buf is 696, I make my buf size a liitle bit exceed the limit as 700, and 700 | 0xF0000000 would be 0x800002BC, which should be 2147484348 as unsigned. And I add this count to my buf with a ",", and I add the address of buf to it, and fill it with NOP, and then I add shellcode to it. Unfortunately, here is a segment fault triggered in memcpy, after I viewed the posts in Piazza I still can't figure it out. 
